syntax = "proto3";

import "google/protobuf/empty.proto";

package storage_broker;

service BrokerService {
    // Subscribe to safekeeper updates.
    rpc SubscribeSafekeeperInfo(SubscribeSafekeeperInfoRequest) returns (stream SafekeeperTimelineInfo) {};

    // Publish safekeeper updates.
    rpc PublishSafekeeperInfo(stream SafekeeperTimelineInfo) returns (google.protobuf.Empty) {};

    // Subscribe to all messages, limited by a filter.
    rpc SubscribeByFilter(SubscribeByFilterRequest) returns (stream TypedMessage) {};

    // Publish one message.
    rpc PublishOne(TypedMessage) returns (google.protobuf.Empty) {};
}

message SubscribeSafekeeperInfoRequest {
    oneof subscription_key {
        google.protobuf.Empty all = 1; // subscribe to everything
        TenantTimelineId tenant_timeline_id = 2; // subscribe to specific timeline
    }
}

message SafekeeperTimelineInfo {
    uint64 safekeeper_id = 1;
    TenantTimelineId tenant_timeline_id = 2;
    // Safekeeper term
    uint64 term = 12;
    // Term of the last entry.
    uint64 last_log_term = 3;
    // LSN of the last record.
    uint64 flush_lsn = 4;
    // Up to which LSN safekeeper regards its WAL as committed.
    uint64 commit_lsn = 5;
    // LSN up to which safekeeper has backed WAL.
    uint64 backup_lsn = 6;
    // LSN of last checkpoint uploaded by pageserver.
    uint64 remote_consistent_lsn = 7;
    uint64 peer_horizon_lsn = 8;
    uint64 local_start_lsn = 9;
    // A connection string to use for WAL receiving.
    string safekeeper_connstr = 10;
    // HTTP endpoint connection string
    string http_connstr = 13;
    // Availability zone of a safekeeper.
    optional string availability_zone = 11;
}

message TenantTimelineId {
    bytes tenant_id = 1;
    bytes timeline_id = 2;
}

message FilterTenantTimelineId {
    enum Mode {
        // Invalid mode.
        INVALID = 0;

        // Subscribe to all timelines.
        ALL_TIMELINES = 1;

        // Subscribe to a specific timeline.
        SPECIFIC_TIMELINE = 2;
    }

    Mode mode = 1;

    // Valid only if mode == SPECIFIC_TIMELINE.
    optional TenantTimelineId tenant_timeline_id = 2;
}

message SubscribeByFilterRequest {
    // Subscription will emit messages only of the specified types.
    repeated MessageType types = 1;

    // Subscription will emit messages only for the specified tenant/timeline.
    FilterTenantTimelineId tenant_timeline_id = 2;
}

enum MessageType {
    UNKNOWN = 0;
    SAFEKEEPER_TIMELINE_INFO = 2;
}

// A message with a type.
message TypedMessage {
    MessageType type = 1;

    optional SafekeeperTimelineInfo safekeeper_timeline_info = 2;
}
